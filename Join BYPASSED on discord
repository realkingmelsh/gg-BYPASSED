-- ==========================================
-- SCRIPT 2
do
	local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local MarketplaceService = game:GetService("MarketplaceService")

local player = Players.LocalPlayer

-- Cleanup if re-ran
local CLEAN_KEY = "__AnimSpeedCaptureUI_Cleanup"
local env = (getgenv and getgenv()) or _G
if env[CLEAN_KEY] then
    pcall(env[CLEAN_KEY])
end

-- ===================== LOCKED UI POSITION =====================
local LOCKED_X = 980
local LOCKED_Y = 553
local FRAME_W = 380
local FRAME_H = 340 

local function getLockedPos()
    local cam = workspace.CurrentCamera
    if cam then
        local vs = cam.ViewportSize
        local x = math.clamp(LOCKED_X, 0, math.max(0, vs.X - FRAME_W))
        local y = math.clamp(LOCKED_Y, 0, math.max(0, vs.Y - FRAME_H))
        return UDim2.fromOffset(x, y)
    end
    return UDim2.fromOffset(LOCKED_X, LOCKED_Y)
end

-- ===================== State =====================
local speedAbs = 0.00003
local paused = false
local direction = 1 
local uiVisible = true
local isAnimationActive = false -- NEW: Tracks if we should be playing

local savedAnimations = {} 
local selectedEntry = nil 

-- ===================== Runtime =====================
local gui, frame, listFrame, statusLabel, speedBox, pauseBtn, dirBtn
local humanoid, animator
local currentTrack

local conns = {}
local function addConn(c) table.insert(conns, c) return c end
local function disconnectAll()
    for _, c in ipairs(conns) do pcall(function() c:Disconnect() end) end
    table.clear(conns)
end

-- ===================== Logic =====================

local function appliedSpeed()
    if paused then return 0 end
    return direction * speedAbs
end

local function applyToAllTracks()
    if not animator then return end
    local s = appliedSpeed()
    for _, t in ipairs(animator:GetPlayingAnimationTracks()) do
        pcall(function() t:AdjustSpeed(s) end)
    end
end

local function refreshStatus()
    if not statusLabel then return end
    local dirText = (direction == 1) and "Forward" or "Reverse"
    local playText = paused and "Paused" or "Playing"
    statusLabel.Text = string.format("State: %s | Dir: %s | Applied: %.6f", playText, dirText, appliedSpeed())
end

local function setButtonHighlight()
    if not listFrame then return end
    for _, child in ipairs(listFrame:GetChildren()) do
        if child:IsA("TextButton") then
            local entryId = child:GetAttribute("AnimId")
            local entryTime = child:GetAttribute("Timestamp")
            
            if selectedEntry and selectedEntry.id == entryId and selectedEntry.timestamp == entryTime then
                child.BackgroundColor3 = Color3.fromRGB(70, 140, 70) 
            else
                child.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
            end
        end
    end
end

local function playSavedAnimation(entry)
    if not humanoid or not animator or not entry then return end

    if currentTrack then
        pcall(function() currentTrack:Stop(0.05) end)
    end

    local animObj = Instance.new("Animation")
    animObj.AnimationId = entry.id

    local ok, track = pcall(function() return animator:LoadAnimation(animObj) end)
    if ok and track then
        currentTrack = track
        currentTrack.Looped = true
        currentTrack.Priority = Enum.AnimationPriority.Action4 -- High priority to ensure visibility
        currentTrack:Play(0.05)
        currentTrack.TimePosition = entry.timestamp
        currentTrack:AdjustSpeed(appliedSpeed())
        isAnimationActive = true -- Mark as active
    end
    refreshStatus()
end

local function toggleAnimation()
    if not selectedEntry then return end
    
    if currentTrack and currentTrack.IsPlaying then
        currentTrack:Stop(0.1)
        isAnimationActive = false -- User manually stopped it
    else
        playSavedAnimation(selectedEntry)
    end
end

-- ===================== UI Elements =====================

local function createSavedButton(entry)
    if not listFrame then return end

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, -10, 0, 36)
    btn.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
    btn.TextColor3 = Color3.fromRGB(255, 255, 255)
    btn.Font = Enum.Font.Gotham
    btn.TextSize = 14
    btn.TextXAlignment = Enum.TextXAlignment.Left
    btn.Text = string.format("  %s (@ %.3fs)", entry.name, entry.timestamp)
    btn.Parent = listFrame
    btn:SetAttribute("AnimId", entry.id)
    btn:SetAttribute("Timestamp", entry.timestamp)
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

    addConn(btn.MouseButton1Click:Connect(function()
        selectedEntry = entry
        setButtonHighlight()
        playSavedAnimation(entry)
    end))

    setButtonHighlight()
end

local function captureCurrentAnimation()
    if not humanoid then return end
    local tracks = humanoid:GetPlayingAnimationTracks()
    if #tracks == 0 then return end

    local best = tracks[1]
    local bestWeight = -math.huge
    for _, t in ipairs(tracks) do
        local w = t.WeightCurrent
        if t.Length ~= 0 and w > bestWeight and t.Animation and t.Animation.AnimationId then
            best = t
            bestWeight = w
        end
    end

    if best then
        local digits = best.Animation.AnimationId:match("%d+")
        local id = "rbxassetid://" .. digits
        local timestamp = best.TimePosition
        
        local name = "Animation"
        pcall(function()
            name = MarketplaceService:GetProductInfo(tonumber(digits)).Name
        end)

        local entry = { id = id, name = name, timestamp = timestamp }
        table.insert(savedAnimations, entry)
        createSavedButton(entry)
        selectedEntry = entry
        setButtonHighlight()
    end
end

-- ===================== UI BUILDER =====================

local function buildUI()
    local pg = player:WaitForChild("PlayerGui")
    if pg:FindFirstChild("AnimSpeedCaptureUI") then pg.AnimSpeedCaptureUI:Destroy() end

    gui = Instance.new("ScreenGui")
    gui.Name = "AnimSpeedCaptureUI"
    gui.ResetOnSpawn = false
    gui.Parent = pg

    frame = Instance.new("Frame")
    frame.Size = UDim2.fromOffset(FRAME_W, FRAME_H)
    frame.Position = getLockedPos()
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BorderSizePixel = 0
    frame.Visible = uiVisible
    frame.Parent = gui
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 14)
    local stroke = Instance.new("UIStroke", frame)
    stroke.Thickness = 2
    stroke.Color = Color3.fromRGB(50, 50, 50)

    local function enforce() frame.Position = getLockedPos() end
    addConn(frame:GetPropertyChangedSignal("Position"):Connect(enforce))

    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, 0, 0, 34)
    title.BackgroundTransparency = 1
    title.Text = "Animation Speed Controller"
    title.Font = Enum.Font.GothamBold
    title.TextSize = 16
    title.TextColor3 = Color3.new(1, 1, 1)

    speedBox = Instance.new("TextBox", frame)
    speedBox.Size = UDim2.new(1, -120, 0, 32)
    speedBox.Position = UDim2.new(0, 10, 0, 45)
    speedBox.Text = tostring(speedAbs)
    speedBox.Font = Enum.Font.Gotham
    speedBox.TextSize = 16
    speedBox.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    speedBox.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", speedBox).CornerRadius = UDim.new(0, 8)

    local applyBtn = Instance.new("TextButton", frame)
    applyBtn.Size = UDim2.new(0, 90, 0, 32)
    applyBtn.Position = UDim2.new(1, -100, 0, 45)
    applyBtn.Text = "Apply"
    applyBtn.Font = Enum.Font.GothamBold
    applyBtn.TextSize = 16
    applyBtn.BackgroundColor3 = Color3.fromRGB(50, 120, 50)
    applyBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", applyBtn).CornerRadius = UDim.new(0, 8)

    statusLabel = Instance.new("TextLabel", frame)
    statusLabel.Size = UDim2.new(1, -20, 0, 20)
    statusLabel.Position = UDim2.new(0, 10, 0, 85)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 14
    statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left
    statusLabel.Parent = frame

    local captureBtn = Instance.new("TextButton", frame)
    captureBtn.Size = UDim2.new(1, -20, 0, 38)
    captureBtn.Position = UDim2.new(0, 10, 0, 110)
    captureBtn.Text = "Capture Current Animation"
    captureBtn.Font = Enum.Font.GothamBold
    captureBtn.TextSize = 16
    captureBtn.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    captureBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", captureBtn).CornerRadius = UDim.new(0, 10)

    listFrame = Instance.new("ScrollingFrame", frame)
    listFrame.Size = UDim2.new(1, -20, 0, 110)
    listFrame.Position = UDim2.new(0, 10, 0, 160)
    listFrame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
    listFrame.BorderSizePixel = 0
    listFrame.ScrollBarThickness = 4
    Instance.new("UICorner", listFrame)

    local layout = Instance.new("UIListLayout", listFrame)
    layout.Padding = UDim.new(0, 5)
    addConn(layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        listFrame.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y + 5)
    end))

    pauseBtn = Instance.new("TextButton", frame)
    pauseBtn.Size = UDim2.new(0.5, -15, 0, 40)
    pauseBtn.Position = UDim2.new(0, 10, 1, -50)
    pauseBtn.Font = Enum.Font.GothamBold
    pauseBtn.TextSize = 16
    pauseBtn.BackgroundColor3 = Color3.fromRGB(140, 90, 40)
    pauseBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", pauseBtn).CornerRadius = UDim.new(0, 10)

    dirBtn = Instance.new("TextButton", frame)
    dirBtn.Size = UDim2.new(0.5, -15, 0, 40)
    dirBtn.Position = UDim2.new(0.5, 5, 1, -50)
    dirBtn.Font = Enum.Font.GothamBold
    dirBtn.TextSize = 16
    dirBtn.BackgroundColor3 = Color3.fromRGB(60, 90, 140)
    dirBtn.TextColor3 = Color3.new(1, 1, 1)
    Instance.new("UICorner", dirBtn).CornerRadius = UDim.new(0, 10)

    addConn(applyBtn.MouseButton1Click:Connect(function()
        local n = tonumber(speedBox.Text)
        if n then speedAbs = math.abs(n) end
        applyToAllTracks()
        refreshStatus()
    end))

    addConn(captureBtn.MouseButton1Click:Connect(captureCurrentAnimation))

    addConn(pauseBtn.MouseButton1Click:Connect(function()
        paused = not paused
        pauseBtn.Text = paused and "Play" or "Pause"
        applyToAllTracks()
        refreshStatus()
    end))

    addConn(dirBtn.MouseButton1Click:Connect(function()
        direction = (direction == 1) and -1 or 1
        dirBtn.Text = (direction == 1) and "Forward" or "Reverse"
        applyToAllTracks()
        refreshStatus()
    end))

    pauseBtn.Text = paused and "Play" or "Pause"
    dirBtn.Text = (direction == 1) and "Forward" or "Reverse"
    for _, entry in ipairs(savedAnimations) do createSavedButton(entry) end
    refreshStatus()
end

-- ===================== INIT =====================

local function bindCharacter()
    local char = player.Character or player.CharacterAdded:Wait()
    humanoid = char:WaitForChild("Humanoid")
    animator = humanoid:WaitForChild("Animator")

    -- AUTO-RESTART: If we were playing an animation before death, play it again
    if isAnimationActive and selectedEntry then
        task.defer(function()
            playSavedAnimation(selectedEntry)
        end)
    end

    addConn(animator.AnimationPlayed:Connect(function(track)
        task.defer(function()
            pcall(function() track:AdjustSpeed(appliedSpeed()) end)
        end)
    end))
end

local function setupKeybinds()
    addConn(UserInputService.InputBegan:Connect(function(input, gp)
        if gp or UserInputService:GetFocusedTextBox() then return end
        if input.KeyCode == Enum.KeyCode.Minus or input.KeyCode == Enum.KeyCode.KeypadMinus then
            uiVisible = not uiVisible
            if frame then frame.Visible = uiVisible end
        end
        if input.KeyCode == Enum.KeyCode.E then
            toggleAnimation()
        end
    end))
end

local function start()
    disconnectAll()
    buildUI()
    bindCharacter()
    setupKeybinds()
end

start()

local respawnConn = player.CharacterAdded:Connect(function()
    task.wait(0.2)
    start()
end)

env[CLEAN_KEY] = function()
    disconnectAll()
    if respawnConn then respawnConn:Disconnect() end
    if gui then gui:Destroy() end
end
end
-- ==========================================
-- SCRIPT 4
-- ==========================================
do
    print("--- Starting Script 4 ---")
    
    -- PASTE CONTENT OF SCRIPT 4 BELOW THIS LINE
	-- Executor-safe HipHeight slider + editable Max
-- LOCKED + RESPAWN-SAFE + SNAPS NEXT TO "Animation Speed Controller" GUI
-- PRESS "-" TO HIDE/UNHIDE | PRESS "R" TO TOGGLE BETWEEN 2.0 AND MAX

if not game:IsLoaded() then
    game.Loaded:Wait()
end

-- Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

-- Cleanup if re-ran
local CLEAN_KEY = "__HipHeightSliderGUI_Cleanup"
local env = (getgenv and getgenv()) or _G
if env[CLEAN_KEY] then
    pcall(env[CLEAN_KEY])
end

-- Config
local MIN_HIP_HEIGHT = 2.0 -- Base height set to 2.0
local DEFAULT_HIP_HEIGHT = 2.0

-- User-changeable max
local maxHipHeight = 50 -- Default Max set to 50 as requested
local MAX_ALLOWED_HIP_HEIGHT = 1000000

-- Persist current across respawns/restarts
local currentHipHeight = DEFAULT_HIP_HEIGHT

-- UI visibility state
local uiVisible = true

-- GUI reference
local currentScreenGui = nil

-- Connections
local scriptConnections = {}
local function addConn(c) table.insert(scriptConnections, c) return c end

local function disconnectScriptConnections()
    for _, c in ipairs(scriptConnections) do
        pcall(function() c:Disconnect() end)
    end
    table.clear(scriptConnections)
end

local function waitForNonZeroAbsoluteSize(guiObj)
    while guiObj.AbsoluteSize.X <= 0 or guiObj.AbsoluteSize.Y <= 0 do
        RunService.Heartbeat:Wait()
    end
end

-- ===================== POSITION LOGIC =====================
local TARGET_GUI_NAME = "AnimSpeedCaptureUI"
local GAP_PX = 10
local FRAME_W = 380
local FRAME_H = 200
local FALLBACK_X = 541
local FALLBACK_Y = 670

local function getViewport()
    local cam = workspace.CurrentCamera
    if cam then return cam.ViewportSize end
    return Vector2.new(1920, 1080)
end

local function clampToScreen(x, y)
    local vs = getViewport()
    x = math.clamp(x, 0, math.max(0, vs.X - FRAME_W))
    y = math.clamp(y, 0, math.max(0, vs.Y - FRAME_H))
    return x, y
end

local function findTargetFrame(playerGui)
    local targetGui = playerGui:FindFirstChild(TARGET_GUI_NAME)
    if not targetGui then return nil end
    return targetGui:FindFirstChildWhichIsA("Frame")
end

local function computeSnappedPos(playerGui, targetFrame)
    if targetFrame and targetFrame.AbsoluteSize.X > 0 and targetFrame.AbsoluteSize.Y > 0 then
        local tx = targetFrame.AbsolutePosition.X
        local ty = targetFrame.AbsolutePosition.Y
        local th = targetFrame.AbsoluteSize.Y
        local x = tx - FRAME_W - GAP_PX
        local y = ty + th - FRAME_H
        x, y = clampToScreen(x, y)
        return UDim2.fromOffset(x, y)
    end
    local x, y = clampToScreen(FALLBACK_X, FALLBACK_Y)
    return UDim2.fromOffset(x, y)
end

local function lockFrameNextToTarget(frame, playerGui)
    if not frame then return end
    local guarding = false
    local targetFrame = nil

    local function enforce()
        if guarding or not frame or not frame.Parent then return end
        guarding = true
        if (not targetFrame) or (not targetFrame.Parent) then
            targetFrame = findTargetFrame(playerGui)
        end
        frame.AnchorPoint = Vector2.new(0, 0)
        frame.Size = UDim2.fromOffset(FRAME_W, FRAME_H)
        frame.Position = computeSnappedPos(playerGui, targetFrame)
        guarding = false
    end

    enforce()
    addConn(frame:GetPropertyChangedSignal("Position"):Connect(enforce))
    addConn(RunService.Heartbeat:Connect(enforce))
end

-- ===================== MAIN SCRIPT =====================
local function startScript()
    disconnectScriptConnections()
    if currentScreenGui and currentScreenGui.Parent then
        currentScreenGui:Destroy()
    end

    local player = Players.LocalPlayer
    if not player then return end

    local humanoid = nil
    local function applyHeightToHumanoid()
        if humanoid and humanoid.Parent then
            humanoid.HipHeight = currentHipHeight
        end
    end

    local function setHumanoidFromCharacter(char)
        humanoid = char:WaitForChild("Humanoid")
        applyHeightToHumanoid()
    end

    if player.Character then setHumanoidFromCharacter(player.Character) end
    addConn(player.CharacterAdded:Connect(setHumanoidFromCharacter))

    local playerGui = player:WaitForChild("PlayerGui")
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "HipHeightSliderGUI"
    screenGui.ResetOnSpawn = false
    screenGui.IgnoreGuiInset = true
    screenGui.Enabled = uiVisible
    screenGui.Parent = playerGui
    currentScreenGui = screenGui

    local frame = Instance.new("Frame")
    frame.Name = "HipHeightControl"
    frame.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    frame.BackgroundTransparency = 0.1
    frame.BorderSizePixel = 0
    frame.Visible = uiVisible
    frame.Parent = screenGui

    lockFrameNextToTarget(frame, playerGui)
    Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

    local titleLabel = Instance.new("TextLabel")
    titleLabel.Size = UDim2.new(1, 0, 0, 32)
    titleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    titleLabel.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
    titleLabel.Font = Enum.Font.SourceSansBold
    titleLabel.TextSize = 20
    titleLabel.Parent = frame

    local function refreshTitle()
        titleLabel.Text = string.format("Hip Height (%.1f-%.0f)", MIN_HIP_HEIGHT, maxHipHeight)
    end
    refreshTitle()

    -- Max Input Row
    local maxBox = Instance.new("TextBox")
    maxBox.Size = UDim2.new(0, 220, 0, 26)
    maxBox.Position = UDim2.new(0, 70, 0, 40)
    maxBox.Text = tostring(maxHipHeight)
    maxBox.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    maxBox.TextColor3 = Color3.fromRGB(255, 255, 255)
    maxBox.ClearTextOnFocus = false
    maxBox.Parent = frame
    Instance.new("UICorner", maxBox)

    local setMaxButton = Instance.new("TextButton")
    setMaxButton.Size = UDim2.new(0, 70, 0, 26)
    setMaxButton.Position = UDim2.new(0, 300, 0, 40)
    setMaxButton.Text = "Set Max"
    setMaxButton.BackgroundColor3 = Color3.fromRGB(0, 120, 255)
    setMaxButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    setMaxButton.Parent = frame
    Instance.new("UICorner", setMaxButton)

    -- Slider Track
    local sliderBackground = Instance.new("Frame")
    sliderBackground.Size = UDim2.new(0.9, 0, 0, 10)
    sliderBackground.Position = UDim2.new(0.5, 0, 0, 100)
    sliderBackground.AnchorPoint = Vector2.new(0.5, 0)
    sliderBackground.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
    sliderBackground.Parent = frame

    local sliderKnob = Instance.new("TextButton")
    sliderKnob.Size = UDim2.new(0, 20, 0, 25)
    sliderKnob.AnchorPoint = Vector2.new(0.5, 0.5)
    sliderKnob.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
    sliderKnob.Text = ""
    sliderKnob.Parent = sliderBackground
    Instance.new("UICorner", sliderKnob)

    local valueLabel = Instance.new("TextLabel")
    valueLabel.Size = UDim2.new(1, 0, 0, 28)
    valueLabel.Position = UDim2.new(0, 0, 0, 135)
    valueLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    valueLabel.BackgroundTransparency = 1
    valueLabel.Font = Enum.Font.SourceSans
    valueLabel.TextSize = 18
    valueLabel.Parent = frame

    waitForNonZeroAbsoluteSize(sliderBackground)

    local function updateLabel()
        valueLabel.Text = string.format("Hip Height: %.2f", currentHipHeight)
    end

    local function setKnobFromHipHeight(hh)
        local trackWidth = sliderBackground.AbsoluteSize.X
        local knobHalf = sliderKnob.AbsoluteSize.X / 2
        local minX, maxX = knobHalf, trackWidth - knobHalf
        
        currentHipHeight = math.clamp(hh, MIN_HIP_HEIGHT, maxHipHeight)
        local range = maxHipHeight - MIN_HIP_HEIGHT
        local ratio = (currentHipHeight - MIN_HIP_HEIGHT) / (range > 0 and range or 1)
        
        sliderKnob.Position = UDim2.new(0, minX + ratio * (maxX - minX), 0.5, 0)
        updateLabel()
        applyHeightToHumanoid()
    end

    local function updateFromKnobPos(newPosition)
        local trackWidth = sliderBackground.AbsoluteSize.X
        local knobHalf = sliderKnob.AbsoluteSize.X / 2
        local minX, maxX = knobHalf, trackWidth - knobHalf
        local clampedX = math.clamp(newPosition, minX, maxX)
        
        sliderKnob.Position = UDim2.new(0, clampedX, 0.5, 0)
        local ratio = (clampedX - minX) / (maxX - minX)
        currentHipHeight = MIN_HIP_HEIGHT + (ratio * (maxHipHeight - MIN_HIP_HEIGHT))
        
        updateLabel()
        applyHeightToHumanoid()
    end

    -- Input Logic (Minus to Toggle GUI, R to Toggle Height)
    addConn(UserInputService.InputBegan:Connect(function(input, processed)
        if processed or UserInputService:GetFocusedTextBox() then return end
        
        if input.KeyCode == Enum.KeyCode.Minus or input.KeyCode == Enum.KeyCode.KeypadMinus then
            uiVisible = not uiVisible
            screenGui.Enabled = uiVisible
        end
        
        if input.KeyCode == Enum.KeyCode.T then
            -- If already at Max, go to Base. Otherwise, go to Max.
            if math.abs(currentHipHeight - maxHipHeight) < 0.1 then
                setKnobFromHipHeight(MIN_HIP_HEIGHT)
            else
                setKnobFromHipHeight(maxHipHeight)
            end
        end
    end))

    -- Slider Dragging
    local isDragging = false
    addConn(sliderKnob.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = true
        end
    end))
    addConn(UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
            isDragging = false
        end
    end))
    addConn(UserInputService.InputChanged:Connect(function(input)
        if isDragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            updateFromKnobPos(input.Position.X - sliderBackground.AbsolutePosition.X)
        end
    end))

    -- Update Max
    local function applyMax()
        local n = tonumber(maxBox.Text)
        if n then
            maxHipHeight = math.clamp(n, MIN_HIP_HEIGHT + 0.1, MAX_ALLOWED_HIP_HEIGHT)
            maxBox.Text = tostring(maxHipHeight)
            refreshTitle()
            -- Sync the slider position to the current height relative to new max
            setKnobFromHipHeight(currentHipHeight)
        end
    end
    addConn(setMaxButton.MouseButton1Click:Connect(applyMax))
    addConn(maxBox.FocusLost:Connect(function(enter) if enter then applyMax() end end))

    -- Initial Sync
    setKnobFromHipHeight(currentHipHeight)
end

startScript()

env[CLEAN_KEY] = function()
    disconnectScriptConnections()
    if currentScreenGui then pcall(function() currentScreenGui:Destroy() end) end
end
    
    
    -- PASTE CONTENT OF SCRIPT 4 ABOVE THIS LINE
    print("--- Script 4 Finished ---")
end

print("Done! All 4 scripts have been executed.")
do
	local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- SETTINGS
local ResetKey = Enum.KeyCode.Equals -- Key: =

print("!!! Perfect Instant Reset Active !!!")

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if input.KeyCode == ResetKey and not gameProcessed then
        
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChild("Humanoid")
        
        if root and hum then
            -- 1. SAVE POSITION & CAMERA ANGLE
            local savedCFrame = root.CFrame
            local savedCamCFrame = workspace.CurrentCamera.CFrame
            
            -- 2. RESET
            hum.Health = 0
            
            -- 3. WAIT FOR NEW CHARACTER
            local connection
            connection = LocalPlayer.CharacterAdded:Connect(function(newChar)
                connection:Disconnect() 
                
                local newRoot = newChar:WaitForChild("HumanoidRootPart", 10)
                
                if newRoot then
                    -- 4. THE "SMOOTH" RESTORE
                    -- We use task.defer to run the teleport at the very first physics frame
                    task.defer(function()
                        newRoot.CFrame = savedCFrame
                        workspace.CurrentCamera.CFrame = savedCamCFrame
                        
                        -- Optional: Stop any gravity/velocity carryover
                        newRoot.AssemblyLinearVelocity = Vector3.zero
                    end)
                    
                    -- 5. THE ANTI-GLITCH TAP
                    -- One more silent check slightly later to ensure the map didn't pull you away
                    for i = 1, 3 do
                        task.wait(0.03)
                        if newRoot then
                            newRoot.CFrame = savedCFrame
                        end
                    end
                end
            end)
        end
    end
end)
end
-- ==========================================
-- SCRIPT 1
-- ==========================================
do
    print("--- Starting Script 1 ---")
    
    -- PASTE CONTENT OF SCRIPT 1 BELOW THIS LINE
	loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
execCmd("animation 93224413172183")
execCmd("maxzoom 200")
    
    -- PASTE CONTENT OF SCRIPT 1 ABOVE THIS LINE
    print("--- Script 1 Finished ---")
end
